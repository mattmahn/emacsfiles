#+TITLE: Literate Emacs Configuration
#+OPTIONS: toc:3

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Matthew Mahnke")
#+END_SRC

Avoid loading old bytecode instead of newer source.
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

* My functions

  #+BEGIN_SRC emacs-lisp
    ;; default to UTF-8
    (prefer-coding-system 'utf-8)
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
    (setq
     ;; don't save customizations to init file
     custom-file (concat user-emacs-directory ".emacs-customize.el")
     require-final-newline t
     )

    ;; open URLs in default browser
    (when (display-graphic-p)
      (setq browse-url-browser-function 'browse-url-default-macosx-browser))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (defun my/use-eslint-from-node-modules ()
      "Programmatically change ‘flycheck-javscript-eslint-executable’ to use the local node_modules version before the globally installed version.

    The directories are searched recursively up the the tree until a match is found."
      (let ((root (locate-dominating-file
                   (or (buffer-file-name) default-directory)
                   (lambda (dir)
                     (let ((eslint (expand-file-name "node_modules/.bin/eslint" dir)))
                       (and eslint (file-executable-p eslint)))))))
        (when root
          (let ((eslint (expand-file-name "node_modules/eslint/bin/eslint.js" root)))
            (setq-local flycheck-javascript-eslint-executable eslint)))))
  #+END_SRC

  Let's make a macro that calls =global-set-key= over an alist:
  #+BEGIN_SRC emacs-lisp
    (defmacro my/many-global-set-key (key-alist)
      "Evaluates `global-set-key' with the alist KEY-ALIST."
      `(cl-loop for pair in ,key-alist
                for key = (kbd (car pair))
                for command = (cdr pair)
                do (global-set-key key command)))
  #+END_SRC

* Track Emacs load time

  #+BEGIN_SRC emacs-lisp
    (defconst emacs-start-time (current-time))
  #+END_SRC

* Garbage Collection

  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 20000000) ; 20MB
  #+END_SRC

  Hide the backup files someplace special.
  #+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
         backup-by-copying t  ; don't delink hardlinks
         delete-old-versions t  ; automatically delete excess backups
         )
  #+END_SRC

* Package management
  Let's use =use-package= for package loading because it's super nice.

  First, we need to enable Emacs's built-in package manager and configure the package repositories:
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-enable-at-startup nil)
    (setq package-archives
          '(("gnu"          . "https://elpa.gnu.org/packages/")
            ("melpa"        . "https://melpa.org/packages/")
            ("melpa-stable" . "https://stable.melpa.org/packages/")))
  #+END_SRC

  Now that Emacs knows where to get =use-package=.

  #+BEGIN_SRC emacs-lisp
    (package-initialize)

    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (eval-when-compile
      (require 'use-package))

    ;; always download all packages if not already downloaded
    (setq use-package-always-ensure t)
    ;; keep stats about packages
    (setq use-package-compute-statistics t)

    (use-package diminish) ; no longer included with use-package by default

    ;;; example use-package usage
    ;; (use-package foo
    ;;   :ensure t
    ;;   :defer t
    ;;   :if (display-graphic-p)
    ;;   :commands (foo-all foo-super)
    ;;   :mode "\\.mode\\'"
    ;;   :diminish "f"
    ;;   :init
    ;;   (setq foo-variable t)
    ;;   (evil-leader/set-key "fs" #'foo-super)
    ;;   :config
    ;;   (foo-mode 1))
  #+END_SRC

  Let's also setup automatic package updating:
  #+BEGIN_SRC emacs-lisp
    (use-package auto-package-update
      :ensure t
      :config
      (setq auto-package-update-interval 14 ;; days
            auto-package-update-prompt-before-update t
            auto-package-update-delete-old-versions t
            auto-package-update-hide-results t)
      (auto-package-update-maybe))
  #+END_SRC

** Package-specific configuration
*** Emacs
    Sometimes it is necessary to restart Emacs from within Emacs.
    This makes it as easy as =M-x restart-emacs=.

    #+BEGIN_SRC emacs-lisp
      (use-package restart-emacs
        :defer t)
    #+END_SRC

    It's also nice to have Emacs running in daemon mode, so it starts faster in subsequent invocations:
    #+BEGIN_SRC emacs-lisp
      (use-package server
        :ensure t
        :if (display-graphic-p)
        :init
        (setq server-name "Matt's super secret Emacs server")
        :config
        (unless (server-running-p)
          (add-hook 'after-init-hook 'server-start t)))
    #+END_SRC

    Auto-pair parentheses and such:
    #+BEGIN_SRC emacs-lisp
      (electric-pair-mode 1)
    #+END_SRC

    Save histories:
    #+BEGIN_SRC emacs-lisp
      (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
            savehist-file "~/.emacs.d/savehist")
      (savehist-mode 1)
    #+END_SRC

*** evil-mode
    Emacs's editing sucks. Vim's modal editing is the best.
    #+BEGIN_SRC emacs-lisp
      (use-package evil-leader
        :init
        (setq evil-leader/in-all-states t)
        :config
        ;; load evil-leader first so it's initialized for evil-mode
        (global-evil-leader-mode)
        (evil-leader/set-leader ","))

      (use-package evil
        :config
        (modify-syntax-entry ?_ "w") ; include _ as word character
        (setq evil-move-cursor-back nil)
        ;; set initial evil state for particular modes
        (cl-loop for (mode . state) in '((cider-test-report-mode . emacs)
                                         (dired-mode             . normal)
                                         (magit-mode             . normal)
                                         (magit-status-mode      . emacs)
                                         (magit-diff-mode        . normal)
                                         (magit-log-mode         . normal)
                                         (magit-process-mode     . normal)
                                         (magit-popup-mode       . emacs)
                                         ;; this allows vi-mode in shells
                                         (term-mode              . emacs))
                 do (evil-set-initial-state mode state))
        (evil-mode +1))

      (use-package evil-matchit
        :config
        (global-evil-matchit-mode 1))

      (use-package evil-commentary
        :config
        (evil-commentary-mode))

      (use-package evil-surround
        :config
        (global-evil-surround-mode 1))

      (use-package evil-visualstar
        :config
        (global-evil-visualstar-mode))

      (use-package evil-search-highlight-persist
        :config
        (global-evil-search-highlight-persist t))

      (use-package evil-numbers)
    #+END_SRC

    I tend to highligh blocks and repeatedly change its indentation, so I'll make Emacs re-highlight the visual selection:
    #+BEGIN_SRC emacs-lisp
      (defun my/evil-shift-left-visual ()
        (interactive)
        (evil-shift-left (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))

      (defun my/evil-shift-right-visual ()
        (interactive)
        (evil-shift-right (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))

      (define-key evil-visual-state-map (kbd "<") 'my/evil-shift-left-visual)
      (define-key evil-visual-state-map (kbd ">") 'my/evil-shift-right-visual)
    #+END_SRC

*** Editorconfig
    Because auto-enforced consistence is lovely.
    #+BEGIN_SRC emacs-lisp
      (use-package editorconfig
        :diminish "↹"
        :init
        (setq auto-mode-alist
              (cl-union auto-mode-alist
                        '(("\\.editorconfig\\'" . editorconfig-conf-mode)
                          ("editorconfig\\'"  . editorconfig-conf-mode))))
        :config
        (editorconfig-mode 1))

      ;; set the default tab width (where I'd expect that to be configured)
      (setq default-tab-width 4)
    #+END_SRC

*** Ivy
    Ivy is "an interactive interface for completion in Emacs."
    #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :pin melpa-stable
        :diminish ivy-mode
        :init
        (setq enable-recursive-minibuffers t
              ivy-use-selectable-prompt t
              ivy-use-virtual-buffers t
              ivy-count-format "(%d/%d) ")
        ;; set completion style (http://oremacs.com/swiper/#completion-styles)
        (setq ivy-re-builders-alist
              '((t . ivy--regex-ignore-order)))
        :config
        (ivy-mode +1))

      (use-package swiper
        :pin melpa-stable
        :after (ivy)
        :config
        (global-set-key "\C-s" 'swiper))

      (use-package counsel
        :pin melpa-stable
        :after (ivy)
        :config
        (counsel-mode +1)
        (my/many-global-set-key '(("C-c C-r" . 'ivy-resume)
                                  ("<f6>" . 'ivy-resume)
                                  ;; ("<f1> l" . 'counsel-find-library)
                                  ;; ("<f2> i" . 'counsel-info-lookup-symbol)
                                  ("<f2> u" . 'counsel-unicode-char)
                                  ("C-c g" . 'counsel-git)
                                  ("C-c j" . 'counsel-git-grep)
                                  ("C-c k" . 'counsel-rg)
                                  ))
        (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history))
    #+END_SRC

    Let's make Ivy fancy.
    #+BEGIN_SRC emacs-lisp
      (use-package ivy-rich
        :after (ivy)
        :init
        (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
        :config
        (ivy-rich-mode +1))
    #+END_SRC

*** projectile
    I need a nice project mangement tool, =projectile= will be that.
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :pin melpa-stable
        :diminish projectile-mode
        :bind-keymap ("C-c p" . projectile-command-map)
        :init
        (setq projectile-require-project-root nil
              projectile-completion-system 'ivy)
        :config
        (setq projectile-globally-ignored-directories
              (cl-union projectile-globally-ignored-directories
                        '("node_modules"
                          "venv")))
        (setq projectile-globally-ignored-files
              (cl-union projectile-globally-ignored-files
                        '(".DS_Store"
                          "*.gz"
                          "*.pyc"
                          "*.png"
                          "*.jpg"
                          "*.jar"
                          "*.svg"
                          "*.tgz"
                          "*.zip")))
        (setq projectile-project-root-files
              (cl-union projectile-project-root-files
                        '("go.mod")))
        (projectile-mode +1))
    #+END_SRC

*** Smartparens
    Do some magic with pairs!
    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :hook ((prog-mode-hook) . smartparens-mode)
        :config
        (require 'smartparens-config))
    #+END_SRC

*** aggressive indentation
    Aggressively indent lines because it is (generally) more intuitive.
    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :diminish "⇉"
        :config
        (global-aggressive-indent-mode t)
        (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
        (add-to-list 'aggressive-indent-excluded-modes 'python-mode))
    #+END_SRC

** Auto-completion
   =company-mode= seems to be the defacto tool, so I'll start with that.
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :diminish "⇥"
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-idle-delay 0.5
             company-minimum-prefix-length 2)
       (setq completion-style '(partial-completion substring emacs22))
       :config
       (company-tng-configure-default))
   #+END_SRC

   Lets also get a help pop-up when dawdling on an auto-complete suggestion:
   #+BEGIN_SRC emacs-lisp
     (use-package company-quickhelp
       :init
       (company-quickhelp-mode 1))
   #+END_SRC

** Emoji
   C'mon, who doesn't like emoji!
   #+BEGIN_SRC emacs-lisp
     (use-package emojify
       :defer t
       :init
       (add-hook 'after-init-hook #'global-emojify-mode)
       :config
       (setq emojify-inhibit-major-modes
             (cl-union emojify-inhibit-major-modes
                       '(cider-mode
                         cider-repl-mode
                         cider-test-report-mode
                         sql-mode
                         term-mode
                         web-mode
                         yaml-mode))
             emojify-prog-contexts "comments"))
   #+END_SRC

** Environment merge
   There's an issue with Emacs on macOS where a command works in your shell, but not in Emacs. This ensures the enviroment variable inside Emacs are the same as your shell.
   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :if (memq window-system '(mac ns x))
       :ensure t
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** Key binding discovery
   Sometimes remembering all the key bindings is really hard...
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :diminish which-key-mode
       :config
       (which-key-mode))
   #+END_SRC

** Language Server
   The Language Server Protocol is devleoped by Microsoft to provide more conventional IDE-like features to editors without needing to write a custom, complex backend.
   Instead, one only needs to write a client for the desired language's language server.
   You can also use =company-mode= with LSP.

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :commands lsp
       :hook (prog-mode . lsp))

     ;; TODO: make the window disappear/behave normally && hide line numbers
     (defun my/hide-frame-line-numbers (frame _window)
       "Hides line nunmbers from a specific frame in a winow."
       (select-frame frame)
       (display-line-numbers-mode -1))

     (use-package lsp-ui
       :commands lsp-ui-mode
       :hook (lsp-mode . lsp-ui-mode)
       :config
       (setq lsp-ui-sideline-ignore-duplicate t)
       ;; (add-hook 'lsp-ui-doc-frame-hook #'my/hide-frame-line-numbers)
       )

     (use-package company-lsp
       :commands company-lsp
       :config
       (push 'company-lsp company-backends)
       (setq company-lsp-async t
             company-lsp-cache-candidates 'auto
             company-lsp-enable-recompletion t))
   #+END_SRC

** Language support
   TODO, because there's too many...

   =orgpop= is a nifty little package that can extract code comment blocks into a temporary buffer for editing, like Org's =org-edit-src-code=.
   #+BEGIN_SRC emacs-lisp
     (use-package poporg
       :bind ("C-c \"" . poporg-dwim))
   #+END_SRC

*** Docker
    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode "Dockerfile")
    #+END_SRC

*** Go
    Get the basic Go mode:
    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :mode "\\(\\.go\\|go.mod\\|go.sum\\)\\'"
        :hook ((before-save . gofmt-before-save)))
    #+END_SRC
    Use an LSP for fancier Go things; =go get -u github.com/saibing/bingo= is needed to install the language server.
*** JavaScript
    The LSP client for JavaScript/TypeScript needs to be installed via npm before you can use it: =npm install -g javascript-typescript-langserver=.
    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :mode ("\\.js\\'"
               "\\.mjs\\'")
        :hook ((js2-mode typescript-mode-hook) . lsp)
        :init
        (setq-default js2-ignored-warnings '("msg.extra.trailing.comma"
                                             "msg.missing.semi"
                                             "msg.no.side.effects")))

      (use-package indium
        :disabled
        :defer t
        :init
        (add-hook 'js2-mode-hook (lambda ()
                                   (require 'indium)
                                   (indium-interaction-mode)))
        :config
        (evil-leader/set-key-for-mode 'indium-repl-mode
          "cr"  #'indium-repl-clear-output     ; (c)lear (r)epl
          ))
    #+END_SRC

*** JSON
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :defer t)
    #+END_SRC

*** Lisps
    #+BEGIN_SRC emacs-lisp
      (use-package emacs-lisp
        :ensure nil
        :defer t)
    #+END_SRC

*** Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :commands (markdown-mode gfm-mode)
        :mode ("\\.md\\'"
               "\\.mkd\\'"
               "\\.markdown\\'")
        :init
        (setq mardown-command "multimarkdown"))
    #+END_SRC

    To enable editing of code blocks in indirect buffers using =C-c '=:
    #+BEGIN_SRC emacs-lisp
      (use-package edit-indirect)
    #+END_SRC

*** Org
    #+BEGIN_SRC emacs-lisp
      (use-package org-mode
        :ensure nil
        :defer t
        :init
        (setq org-insert-mode-line-in-empty-file t ; for .txt file compatibility
              org-ellipsis "..."
              org-startup-truncated nil ; wrap lines, don't truncate
              org-src-fontify-natively t
              org-src-tab-acts-natively t
              org-src-window-setup 'current-window
              org-M-RET-may-split-line '((default . nil)) ; prevent M-RET from splitting lines
              )
        ;; exporting
        (setq org-export-with-smart-quotes t
              org-html-postamble nil)
        (add-hook 'org-mode-hook
                  (lambda ()
                    (require 'ox-md)
                    (require 'ox-beamer)))

        ;;; gtd settings
        ;; (setq org-todo-keywords
        ;;       '((sequence "TODO" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELLED")))
        ;; (setq org-agenda-files '("~/Dropbox/org/"))
        ;; (setq org-agenda-text-search-extra-files '(agenda-archives))
        ;; (setq org-blank-before-new-entry (quote ((heading) (plain-list-item))))
        ;; (setq org-enforce-todo-dependencies t)
        ;; (setq org-log-done (quote time))
        ;; (setq org-log-redeadline (quote time))
        ;; (setq org-log-reschedule (quote time))

        ;;; keybinds pre load
        (evil-leader/set-key-for-mode 'org-mode
          "es" 'org-edit-special
          "ri" 'ielm)
        (evil-leader/set-key-for-mode 'emacs-lisp-mode
          "cc" 'org-edit-src-exit
          "cC" 'org-edit-src-abort))
    #+END_SRC
*** Python
    Disable tabs in =python-mode=
    #+BEGIN_SRC emacs-lisp
      (add-hook 'python-mode-hook (lambda () (setq indent-tabs-mode nil)))
    #+END_SRC
*** Rust
    #+BEGIN_SRC emacs-lisp
      (use-package rust-mode
        :mode "\\.rs\\'"
        :init
        (setq rust-format-on-save t))
    #+END_SRC

*** Stylesheets
    #+BEGIN_SRC emacs-lisp
      (use-package css-mode
        :ensure nil
        :mode "\\.css\\'")

      (use-package scss-mode
        :mode ("\\.scss\\'"
               "\\.sass\\'"))

      ;; color hex color codes and such
      ;;(use-package rainbow-mode
      ;;  :defer t
      ;;  :diminish rainbow-mode
      ;;  :init
      ;;  (add-hook 'css-mode-hook 'rainbow-mode)
      ;;  (add-hook 'scss-mode-hook 'rainbow-mode))
    #+END_SRC

*** Systemd
    #+BEGIN_SRC emacs-lisp
      (use-package systemd)
    #+END_SRC

*** Terraform
    #+BEGIN_SRC emacs-lisp
      (use-package terraform-mode
        :init
        (add-hook 'terraform-mode-hook #'terraform-format-on-save-mode))
    #+END_SRC

*** TOML
    Gotta have TOML support for Rust! (and other things)
    #+BEGIN_SRC emacs-lisp
      (use-package toml-mode
        :defer t)
    #+END_SRC

*** Web
    I hear good things =web-mode=; let's play.
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :mode ("\\.html\\'"
               "\\.html\\.erb\\'"
               "\\.php\\'"
               "\\.jinja\\'"
               "\\.j2\\'")
        :init
        ;; fix paren matching web-mode conflict for jinja-like templates
        (add-hook
         'web-mode-hook
         (lambda ()
           (setq-local electric-pair-inhibit-predicate
                       (lambda (c)
                         (if (char-equal c ?{) t (electric-pair-default-inhibit c))))))
        :config
        (setq web-mode-code-indent-offset 2
              web-mode-css-indent-offset 2
              web-mode-markup-indent-offset 2)
        (evil-leader/set-key-for-mode 'web-mode
          "fh" #'web-beautify-html))
    #+END_SRC

*** YAML
    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :mode ("\\.yml\\'"
               "\\.yaml\\'"))
    #+END_SRC

** Spell check
   Let's turn on Flyspell when in a text major mode and for comments & strings when in programming mode:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook #'flyspell-mode)
     (add-hook 'prog-mode-hook #'flyspell-prog-mode)
   #+END_SRC
   See [[https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Spell-check.html]] for setting the spell-check program.
** Syntax checking / Linting
   Syntax checking / linting is super important for any text editor, so let's get one.
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :diminish "✓"
       :hook (after-init-hook . global-flycheck-mode)
       :init
       ;; use the ESLint that's installed in node_modules before the global one
       (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
       :config
       ;; disable documentation related emacs lisp checker
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc clojure-cider-typed))
       ;; disable JSHint because ESLint is better
       (setq-default flycheck-disabled-checkers '(javascript-jshint)))
   #+END_SRC

   Display Flycheck errors in-line with the file contents:
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-inline
       :requires (flycheck)
       :hook (flycheck-mode . turn-on-flycheck-inline))
   #+END_SRC

** Terminal settings
   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :defer t
       :init
       (setq multi-term-dedicated-window-height 30
             multi-term-program "/usr/local/bin/zsh")
       (add-hook 'term-mode-hook
                 (lambda ()
                   (setq term-buffer-maximum-size 10000
                         yas-dont-activate t)
                   (setq-local scroll-margin 0
                               scroll-conservatively 0
                               scroll-step 1
                               evil-emacs-state-cursor 'bar
                               global-hl-line-mode nil))))
   #+END_SRC

** UI niceties
   Break lines at word boundries instead of in the middle of words, and show the column:
   #+BEGIN_SRC emacs-lisp
     (global-visual-line-mode 1)
     (column-number-mode 1)
   #+END_SRC

   Disable the annoying bell:
   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

   What's the most important part about a user interface? The font!
   #+BEGIN_SRC emacs-lisp
     (pcase system-type
       ('darwin (add-to-list 'default-frame-alist '(font . "Iosevka-12")))
       (_       (add-to-list 'default-frame-alist '(font . "Iosevka-10:antialias=natural"))))
   #+END_SRC

   Match the titlebar color on macOS
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
     (add-to-list 'default-frame-alist '(ns-appearance . dark))
     (setq ns-use-proxy-icon nil
           frame-title-format nil)
   #+END_SRC

   I also need to turn off all those ugly bars.
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode 1)
     (when (display-graphic-p)
       (tool-bar-mode -1)
       (scroll-bar-mode -1))
   #+END_SRC

   I really don't understand why text editors don't have line numbers enabled by default... Let's turn them and relative numbers on:
   #+BEGIN_SRC emacs-lisp
     (setq-default display-line-numbers 'relative)
   #+END_SRC

   Rainbow parenthesis are really nice to have, assuming it doesn't slow down your editor. They basically make it easy to spot matching parenthesis/braces/brackets.
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-parentheses
       :ensure t
       :hook (prog-mode . highlight-parentheses-mode)
       :init
       (setq hl-paren-colors ;'("Springgreen3" "IndianRed1" "IndianRed3" "IndianRed4")
             '("IndianRed1" "DarkOrange1" "gold2" "Springgreen3" "blue2" "violet")))

     ;; highlight matching parenthesis
     (setq
      show-paren-style 'parenthesis
      show-paren-delay 0)
     (show-paren-mode t)
   #+END_SRC

   Miscellaneous:
   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode)
     ;; highlight current line
     (global-hl-line-mode)
   #+END_SRC

*** Icons
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
	:ensure t)
    #+END_SRC
    After loading this, run =M-x all-the-icons-install-fonts= to install fonts to the operating system.

*** Modeline

    First, lets declutter it:

    #+BEGIN_SRC emacs-lisp
      (diminish 'auto-revert-mode "↺")
      (diminish 'subword-mode)
      (diminish 'undo-tree-mode)
    #+END_SRC

    Eventually I'll put a custom mode-line confiuration here...
    #+BEGIN_SRC emacs-lisp
      (use-package doom-modeline
	:ensure t
	:hook (after-init . doom-modeline-init))
    #+END_SRC

*** Scrolling

    #+BEGIN_SRC emacs-lisp
      ;;; smoother
      (setq scroll-margin 8
            scroll-conservatively 100
            scroll-step 2
            ;; slower on a trackpad
            mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil))
            mouse-wheel-progressive-speed nil)
    #+END_SRC
*** Themes
    #+BEGIN_SRC emacs-lisp
      (use-package ample-theme
        :defer t
        :ensure t
        :init
        (load-theme 'ample t t)
        (load-theme 'ample-flat t t)
        (load-theme 'ample-light t t))
      (use-package nimbus-theme)
      (use-package solarized-theme)

      (enable-theme 'ample)
    #+END_SRC

** Version control
   [[https://magit.vc][Magit]] is probably the best git tool integrated into an editor. Now I just have to learn it...
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :init
       (evil-leader/set-key
         "gg"  #'magit-dispatch-popup
         "gs"  #'magit-status
         "gd"  #'magit-diff-working-tree
         "gco" #'magit-checkout
         "gcb" #'magit-branch-and-checkout
         "gl"  #'magit-pull-from-upstream
         "gaa" #'magit-stage-modified
         "gca" #'magit-commit
         "gpu" #'magit-push-current-to-upstream
         "gp"  #'magit-push-current-to-pushremote
         "gt"  #'magit-tag)
       ;; specific within magit-mode
       (evil-leader/set-key-for-mode 'text-mode
         "cc" 'with-editor-finish
         "cC" 'with-editor-cancel)
       :config
       (setq truncate-lines nil) ; wrap lines
       (define-key magit-status-mode-map (kbd "k") #'previous-line)
       (define-key magit-status-mode-map (kbd "K") #'magit-discard)
       (define-key magit-status-mode-map (kbd "j") #'next-line))
   #+END_SRC

   There's also a project called [[https://magit.vc/manual/forge/index.html][Forge]], also developed by the Magit maintainer, that provides nice integrations with GitHub, GitLab, etc.
   #+BEGIN_SRC emacs-lisp
     (use-package forge
       :disabled ; wait for repo release
       :after (magit)
       :requires (magit))
   #+END_SRC

   Let's get a list of ~TODOs~ in the Magit buffer.  This requires =ripgrep=, =git grep= with PCRE support, or GNU =grep= with PCRE support.
   #+BEGIN_SRC emacs-lisp
     (use-package magit-todos
       :requires (magit)
       :hook (magit-mode . magit-todos-mode))

     (use-package hl-todo
       :config
       (global-hl-todo-mode +1))
   #+END_SRC

   I like to have an indicator of what lines changed. =diff-hl= does a pretty good job, but doesn't play too nice with Flycheck.
   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :ensure t
       :hook ((after-init . global-diff-hl-mode)
              (dired-mode . diff-hl-dir-mode))
       :config
       (if (display-graphic-p)
           (diff-hl-flydiff-mode t)
         (diff-hl-margin-mode t)))
   #+END_SRC

*** YOLO
    Let's emulate my ~git yolo~ alias in Magit: it simply uses a commit message
    from [[http:whatthecommit.com/index.txt][whatthecommit]] as the commit message.
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'load-path (expand-file-name "~/.emacsfiles"))
      (autoload 'my/yolo-commit "yolo")
      (autoload 'my/yolo-commit-editor "yolo")

      (transient-append-suffix 'magit-commit "c"
        '("y" "YOLO" my/yolo-commit-editor))
      (transient-append-suffix 'magit-commit "y"
        '("Y" "YOLO harder" my/yolo-commit))
    #+END_SRC

** Command aliases
   Replace "yes/no" prompts with "y/n" because the other's simply too many letters:
   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Escape evil
   Learning Emacs is way easier when ESC acts like it does in vim
   #+BEGIN_SRC emacs-lisp
     (defun cs-minibuffer-keyboard-quit ()
       "Abort recursive edit.
     In Delete Selection mode, if the mark is active, just deactivate it;
     then it takes a second \\[keyboard-quit] to abort the minibuffer."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark  t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))
   #+END_SRC
* Show package load time
  Here's where we report how long it took to load all installed packages to the Messages buffer.
  #+BEGIN_SRC emacs-lisp
    ;;; show package load time
    (let ((elapsed (float-time (time-subtract (current-time)
                                              emacs-start-time))))
      (message "Loaded packages in %.3fs" elapsed))
  #+END_SRC
